---
title: "Custom Templates"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Custom Templates}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)


# Colors used in graphics to describe different elements
c_orange = "ffa500ff"
c_green  = "44aa00ff"
c_blue   = "0000ffff"
c_purple = "7137c8ff"

ex_yaml = "tree colors:
  roots:
    - white 
    - brown
  trunk:
    bark: brown
  crown:
    branches:
      leaves:  green
      flowers: red"
ex_yaml_tmpfile =  tempfile(fileext=".yaml")
fileConn<-file(ex_yaml_tmpfile)
writeLines(ex_yaml, fileConn)
close(fileConn)

ex_yaml_read = yaml::read_yaml(ex_yaml_tmpfile)
```

## Introduction

The main purpose of ``onbrand`` is to create an abstraction layer that allows for the same reporting workflow to be used with different template documents. In order to do this, the abstraction information needs to be provided in a ``yaml`` configuration file. The process will be detailed below, but at a high level it involves the following steps:

1. Read in a template using the function: ``onbrand::view_layout()``  
2. Use the resulting files to create the mapping (saved as a ``.yaml``)
3. Test the mapping for accuracy using the function: ``onbrand::preview_template()``

The following sections describe this process in detail for both Word and PowerPoint documents. Before you get started, copy the provided examples into your current working directory.  To do so, use the following code:

```{r, eval=FALSE}
library(onbrand)
file.copy(system.file(package="onbrand","examples","example.pptx"), ".", overwrite = TRUE)
file.copy(system.file(package="onbrand","examples","example.docx"), ".", overwrite = TRUE)
file.copy(system.file(package="onbrand","examples","example.yaml"), ".", overwrite = TRUE)
```

This will create the following files:

- ``example.pptx`` - example PowerPoint template
- ``example.docx`` - example Word template
- ``example.yaml`` - example ``yaml`` mapping file (shown at the bottom)

### Mapping and the ``yaml`` file format

Before we start discussing how to create templates we need to talk a little bit about the ``yaml`` file format (and it's recursive nature). If you already understand this, feel free to skip ahead to the relevant section below. 

``onbrand`` utilizes the ``yaml`` file as a method for describing information in a hierarchical manner using key/value pairs. To help understand this better, consider the following example where the colors of the different parts a tree are listed in a hierarchy based on where the parts are located on the tree:

```{r echo=FALSE, comment='', message=TRUE, eval=TRUE}
cat(readLines(ex_yaml_tmpfile) , sep="\n")
```

This example lays out ``key: value`` pairs based on the formatting of the file. The key is followed by both a colon and a space (`: `) which are, in turn, followed by the value.  

- If you have multiple values you can list those below the key (see below about spacing).  
- If the value also has a colon then it's a key for a nested value. 

The main key in the example above is ``tree colors``.  This key has three values: `roots`, `trunk`, and `crown`. One for each section of a Tree.  The hierarchy comes from the indentation. Each of the main sections of Tree are indented two spaces.  Each of these values (`roots`, `trunk`, and `crown`) are also keys themselves because they end with both a colon and a space - and are followed by still more values.

The color values associated with roots are `white` and `brown`. The `root` hierarchy is complete.  

The `trunk` has value `bark`.  But, because `bark` is also indented two spaces and is followed by both a colon and a space, it is also a key with value `brown`. Which completes the `trunk` hierarchy.

The value ``crown`` is indented two spaces and followed by both a space and a colon.  Hence, ``crown`` is a key with value ``branches``.  Again, ``branches`` is indented and followed by both a color and a space.  Then, ``branches`` is also a key with values: ``leaves`` and ``flowers``.  Each of these are also indented and followed by by both a colon and a space.  So, key ``leaves`` has value ``green``. Similarly, key ``flowers`` has value ``red``.  This completes the `crown` hierarchy. 

There is more that can go into a `yaml` file, but this should be enough to help you understand how to create mapping files for `onbrand`.  For more details see (yaml.org)[yaml.org].

## PowerPoint

This section provides a detailed walk-through for each of the three steps in the Introduction.  We recommend everyone walk through this process at least once.  

A quick note about terminology.  A slide master is the top slide in a hierarchy of slides that stores information about the theme and slide layouts of a presentation, including the background, color, fonts, effects, placeholder sizes, and positioning. The slide master is the largest slide image at the top of the slide thumbnail list.

```{r, echo=FALSE, fig.cap="PowerPoint Slide Master Hierarchy", out.width = '600px'}
knitr::include_graphics(system.file(package="onbrand", "graphics", "example_layout_ppt_master.png"))
```

### Step 1: Read the PowerPoint Template  

To create your custom abstraction layer for PowerPoint, you start by reading in your master template.  If you don't already have one, create a PowerPoint template master slide with slide layouts for each of the different layouts you want to use. In this example, we have the ``Office Theme`` Master Slide with two slide layouts:

1. a title slide named: ``title``
2. a content slide with two columns of information named: ``two_col``

**Tip** When you make slide layouts under a master, give each of them a descriptive name that will be easy to use when you are coding later. These names will be used to refer to them within scripts. 

PowerPoint assigns read-only names to every placeholder within each slide layout. To reveal those read-only names, create an annotated slide deck using the ``onbrand::view_layout()`` function:

```{r eval=FALSE}
library(onbrand)
vlres = view_layout(template    = "example.pptx", 
                    output_file = "example_layout.pptx")
```

This will create the file `example_layout.pptx`. It contains a slide for each slide layout (``title`` & ``two_col``) under the master (``Office Theme``) in the input template file (``example.pptx``). On each slide, the names of both the slide layout and slide master will be indicated in the upper right corner. Each placeholder within the slide layout will be shown and is identified by the placeholder label (`ph_label`).  For each placeholder within each slide layout under a slide master, ``onbrand::view_layout()`` produces three pieces of information: `ph_label`, `type`, and `index`.  Notice, there are plenty of duplicate placeholder names. 

### Step 2: Create the PowerPoint Mapping

Before we get to the mapping, take a moment to locate and open the ``example.yaml`` file we copied over at the start of this vignette. In the yaml file there will be a key for mapping PowerPoint templates (rows 1-39 in the file). This key is called `rpptx` and it will have three values (_which are also keys_):

- `master` - Holds the name of the master slide
- `templates` - Has an element for each slide layout you want to use in the template
- `md_def` - Default formatting for when markdown formatting is being used

Within the hierarchy of `rpptx: templates:` there is a value for each slide layout: ``title`` and ``two_col``.  

> _Remember the tip in Step 1 about names?  The name you provided becomes the key to reference the placeholders on the slide in your code._ 

Notice, the ``example.yaml`` doesn't contain all of the placeholders for either slide in the ``example_layout.pptx`` (annotated layout).  **This is because...(I know why on the date and slide number), but why one the footer?**

In the ``yaml``, each placeholder will have two value pairs below it.  For example, the placeholder `sub_title` in slide layout `title` has both `ph_label` and `content_type`.  The `ph_label` maps to the _ph\_label_ from the annotated layout (in the example_layout.pptx). The `content_type` should be either `text` or `list` depending on whether the placeholder contains text or list data. Tables in PowerPoint will be rendered using another method (more on that in the next section).  

The figure below shows how the annotated layout relates to the `yaml` mapping file.

```{r, echo=FALSE, fig.cap="Relationship between slide master names, placeholders, and content type and yaml mapping elements", out.width = '600px'}
knitr::include_graphics(system.file(package="onbrand", "graphics", "example_layout_yaml_pptx.png"))
```

**Note: You only have to define mapping information for the slide layouts under a master you want to access in R. You can have as many masters defined in the template as you want and only use a subset in R.**


### Defining markdown defaults

Now you need to define the defaults for rendering components with markdown (see the Workflow vignette for more information on how this is used). For this you need to create elements in the following hierarchy:
```
rpptx:
  md_def:
    default:      
      color:                 black
      font.size:             12
      bold:                  TRUE
      italic:                FALSE
      underlined:            FALSE
      font.family:           Helvetica
      vertical.align:        baseline
      shading.color:         transparent
    Table_Labels:
      color:                 black
      font.size:             12
      bold:                  TRUE
      italic:                FALSE
      underlined:            FALSE
      font.family:           Helvetica
      vertical.align:        baseline
      shading.color:         transparent
```

For PowerPoint templates you need to define the sections: `default` and `Table_Labels`. The `default` is used when rendering general markdown text. The `Table_Labels` is used when markdown is present in table elements like headers. For each of these you need to define the different aspects of fonts. If you're unsure, just leave them with the defaults above. 

### Step 3: Testing and Previewing your template

In R you can read your template by supplying the template and mapping file names:

```{r eval=FALSE}
 obnd = read_template(template = "example.pptx", 
                      mapping  = "example.yaml")
```

When a template is read, ``onbrand`` will check for basic errors. Look for messages in the console to help you debug any issues you may have. 

After reading in the template, you can test the template using ``onbrand::preview_template()``. **Tip** Save the `obnd` file and view it to make sure the mappings are what you expect.

```{r eval=FALSE}
obnd = preview_template(obnd)
save_report(obnd, "example_preview.pptx")
```

If there are no errors, then you are finished.  Otherwise, double check to ensure you followed the guidance above.

## Word

You should begin with an empty Word document that has the styles you want to use defined. In the example here there is one paragraph style and one table style. You can also put placeholders in the document. For example if you wanted to use this template for reports, and you wanted to have "Report NNNN", where NNNN is the report number, in the right header. You could put "Report ===RPTNUM===" in the right header. [Note: if you type the text into Word. This is because while a string may appear to be a contiguous in Word, it may not be so in the underlying XML code. To ensure the string is contiguous you should type the placeholder text into a text editor, copy and paste it into template Word.]. To view all of the styles in the document you can use the `view_layout()` function here as well:

```{r eval=FALSE}
library(onbrand)
vlres = view_layout(template    = "example.docx", 
                    output_file = "example_layout.docx")
```

This will produce a word document that looks something like this:

```{r, echo=FALSE, fig.cap="Word layout examples.", out.width = '600px'}
knitr::include_graphics(system.file(package="onbrand", "graphics", "example_layout_docx.png"))
```

For each paragraph, character and table style, it will show the name and what that style looks like. You can use this when you define elements in you yaml mapping file. In the yaml file there will be a key for mapping Word templates an that key is called `rdocx`. In that document there will be 

- `styles` Mapping of all the styles in the Word document you want to use to the style name in the Word document
- `doc_def` Associating style names you've defined in the `styles` section with default values for the report
- `formatting` General formatting options for the document
- `md_def` Default formatting for styles when markdown is being used

The following sections will walk you through each of these elements in the yaml mapping file.

### `styles`

In this section you will list key/value pairs that represent the name of the style you want to use in R and the style name used in Word. In the example here we have the following styles defined:
```
  styles:
    Plain_Text:               Normal
    Default_Table:            Normal Table
    Table_Caption:            Normal        
    Figure_Caption:           Normal
```

So fo example the `Normal` style is defined in Word, but I'm going to call it `Plain_Text` in the workflows I develop. **Note: The functions of onbrand require you define at least two styles: one paragraph style and one table style.**

### `doc_def`

This section is where the default style mappings are defined. These are key value pars. The keys are required by onbrand, so you have to have an entry for each of thes. The values are the onbrand style names defined in the `styles` section. So in this example if you insert a Word table (`Table`) it will be formatted according to the onbrand style name `Default_Table`.

```
  doc_def:                     
    Text:                     Plain_Text 
    Table:                    Default_Table 
    Table_Caption:            Table_Caption
    Figure_Caption:           Figure_Caption
```

### `formatting`

Basic document formatting s specified here. The `*Caption_Location` keys indicate if captions should be above (`top`) or below (`bottom`) the reporting element. The `*Pre` and `*Post` elements control how numbering is shown in captions. For example the third dable would look like: `Table 3.`. And the default figure widths and heights are specified here in inches. 

```
  formatting:
    Table_Caption_Location:    top
    Table_Caption_Label_Pre:   "Table "
    Table_Caption_Label_Post:  ". "
    Figure_Caption_Location:   bottom
    Figure_Caption_Label_Pre:  "Figure " 
    Figure_Caption_Label_Post: ". "
    Figure_Width:              6.0
    Figure_Height:             5.0
```

### `md_def`

These elements contain the default values used when markdown formatting is used. For this section you will need entries for `default` and `Table_Labels` as well as an entry for each style defined in the `styles` section.  The `default` is used when rendering general markdown text. The `Table_Labels` is used when markdown is present in table elements like headers. What you can do is open up the styles in Word and make sure that each sytle element (fontsize, bold, etc) matches what is in Word. 

### Testing the new template

Once you're done you can test the template. First read in the template and look at the console for any messages. If you see any issues displayed try to address those. 
```{r eval=FALSE}
 obnd = read_template(template = "example.docx", 
                      mapping  = "example.yaml")
```

If there are no problems you can use `preview_template()` to create an annotated file showing the onbrand mapping names and the Word names with the style applied to visually check the mapping. 

```{r eval=FALSE}
obnd = preview_template(obnd)
save_report(obnd, "example_preview.docx")
```

## Switching Templates

The goal of onbrand is to allow users to easily switch between organizational document templates without changing the actual reporting workflow. This is accomplished through the yaml file. First make a copy of your yaml file for the new templates. Then you need to modify this copy as described below:

### PowerPoint

If you want to change to a new PowerPoint template you need to do the following:

- Create slide masters with the same layout names
- Create the layouts with the same elements as your previous template
- Use `view_layout()` on the new template to get a mapping for the new placeholders
- Edit the new yaml file to to update the master field, ph_label fields, and the md_def field.
- Confirm the new template is behaving as expected using `preview_template()`

### Word

If you want to change to a new Word template you need to do the following:

- Create a document with the same types of styles in your mapping file
- Use `view_layout()` on the new template to get a mapping for the new styles
- Edit the new yaml file to to update the `styles` section to the new names used in Word (keeping the onbrand style names the same)
- Confirm the new template is behaving as expected using `preview_template()`

### Using a new template

Once you have a new template and mapping file you can then use those at the top level of your reporting workflow when calling `read_template()` and that should be it. 

## Maping file
```{r echo=FALSE, comment='', message=TRUE, eval=TRUE}
cat(readLines(file.path(system.file(package="onbrand"), "examples", "example.yaml")) , sep="\n")
```
