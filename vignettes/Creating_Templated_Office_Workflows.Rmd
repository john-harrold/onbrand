---
title: "Templated Workflows"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Templated Workflows}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(onbrand)
library(officer)
library(magrittr)
library(flextable)
```

## Introduction

The ``officer`` package is used to generate all of the underlying PowerPoint and Word documents. This purpose of `onbrand` is to provide an abstraction layer for the functions of ``officer``. This involves providing a consistent customizable method to interact with templates as well as a form of markdown to control the formatting of text. 

This vignette focuses on how to construct workflows using templates. To create your own template see the "Custom Office Templates" vignette. Here we will use the internal templates embedded in the package. For each document type you will need a template file (e.g. PowerPoint or Word document), and a mapping file (`yaml` document). The mapping file can contain information for both PowerPoint and Word templates. The built in mapping file for this example is show at the bottom of the vignette. 

## PowerPoint

### Loading your presentation template

To create a new new `onbrand` object for a PowerPoint document you need to use `read_template()`. This requires that you  supply the path to your PowerPoint document and the mapping file. This example points to files within the `onbrand` package:

```{r}
obnd = read_template(
       template = file.path(system.file(package="onbrand"), "templates", "report.pptx"),
       mapping  = file.path(system.file(package="onbrand"), "templates", "report.yaml"))
```

### Adding content

The mapping file below, and any mapping file you create, should use names for slide masters and placeholders that are descriptive. Once you've read a template into an `onbrand` object, you can add content using `report_add_slide()`. The following will add a slide using the templated `title_slide` layout. The content of the placeholders for that slide is specified using the `elements` argument. This is a list with placeholder names taken from the mapping file. For each placeholder you need to specify the content and the type of content: 

```{r}
obnd = report_add_slide(obnd,
  template = "title_slide",
  elements = list(
     title     = list( content = "Onbrand PowerPoint Example",
                       type    = "text"),
     sub_title = list( content = "Workflow Abstraction",
                       type    = "text")))
```

For a detailed description of the different types of content and the expected format see the help for the `add_pptx_ph_content()` function. Briefly you can specify the following content types:

- `"text"` - a string of text (only possible when the type in the mapping file is text)
- `"list"` - list of information (only possible when the type in the mapping file is list)
- `"imagefile"` - string containing the path to an image file 
- `"ggplot"` -  a ggplot object
- `"table"` - list containing table content and other options
- `"flextable"` - list containing flextable content and other options
- `"flextable_object"` - user-defined flextable object

#### Lists

The previous example showed how to add text content. Note that `text` type can only be used with placeholders where `text` is the type specified in the mapping file. The way lists are created is by defining a vector with paired content of the format `c("indent level", "content", "indent level", "content)`. Where `indent level` indicates a numeric value starting at 1. So we could define the following list content:

```{r}
bl = c("1", "This is first level bullet",
       "2", "sub-bullet",
       "3", "sub-sub-bullet",
       "1", "Another first level bullet")
```

That content can then be added to any placeholder that has `list` as the type in the mapping file:

```{r}
obnd = report_add_slide(obnd,
  template = "content_list",
  elements = list(
     title        = list( content = "Adding List Content",
                          type    = "text"),
     content_body = list( content = bl,
                          type    = "list")))
```

#### Figures

Figures can be added in two ways: either being read in from an image file (e.g. a png) or as a ggplot object. Generally the ggplot object is preferred as it will size automatically according to the dimensions of the placeholder. First lets create some images:

```{r}
library(ggplot2)
p = ggplot() + annotate("text", x=0, y=0, label = "picture example")
imgfile = tempfile(pattern="image", fileext=".png")
ggsave(filename=imgfile, plot=p, height=5.15, width=9, units="in")
```

So now the object`p` contains the ggplot object and `imgfile` is a character object pointing to a png file containing that image. 

```{r}
obnd = report_add_slide(obnd,
  template = "two_content_header_text",
  elements = list(
     title                = list(content  = "Adding Images Content",
                                 type     = "text"),
     content_left_header  = list(content  ="ggplot object",
                                 type     = "text"),
     content_left         = list(content  = p,
                                 type     = "ggplot"),
     content_right_header = list(content  ="image file",
                                 type     = "text"),
     content_right        = list(content  = imgfile,
                                 type     = "imagefile")))
```


#### Tables

Tables can be supplied in three different ways, each providing increasing level of control over the output:

- `table` - This expects a list with the tabular  data and other attributes. It uses the underlying tables in PowerPoint to make the tables. 
- `flextable` - This is a list similar to the `table` above, but instead of using the PowerPoint tables, the table is created using the `flextable` package.
- `flextable_object` - This allows you to create a flextable on your own and use it directly. 

Lets start by creating a simple data frame:

```{r}
tdf =    data.frame(Parameters = c("Length", "Width", "Height"),
                    Values     = 1:3,
                    Units      = c("m", "m", "m") )
```

Using the `table` content type, we just need to provide a list with an element called `table` that contains the data frame. You can add list elements to display header information as well. See the help for `add_pptx_ph_content()` for details.

```{r}
tab_cont = list(table = tdf)
obnd = report_add_slide(obnd,
  template = "content_text", 
  elements = list(
     title         = list( content      = "Tables",
                           type         = "text"),
     sub_title     = list( content      = "Creating PowerPoint Table",
                           type         = "text"),
     content_body  = list( content      = tab_cont,
                           type         = "table")))
```

Sometimes you may want to have a little more control over the tabular output. The `flextable` type can be used for this. What it does is it allows you to supply the data and inforamtion about the flextable to be created, and it will create the flextable for you. 

```{r}
tab_ft = list(table         = tdf,
              header_format = "md",
              header_top    = list(Parameters = "Name^2^",
                                   Values     = "*Value*",
                                   Units      = "**Units**"),
              cwidth        = 0.8,
              table_autofit = TRUE,
              table_theme   = "theme_zebra")
```

Here we are specifying that we want the header format of the table to be rendered as markdown `"md"` and we're specfyign that the top header (there can be top, middle and bottom) should be overwritten (for more on formatting with markdown see the markdown section below). Next we specify some other details like the column width. Again the help for `add_pptx_ph_content()` should cover the details of the list elements that can be supplied.

Alternatively you can create a flextable object directly using the `flextable` package. There is an enormous amount of flexibility in the `flextable` package. Some of these can be seen in the Word examples below, but you should see the documentation for that package to get a feel for what is possible.

```{r}
tab_fto = flextable(tdf)                      
```

You can then add these (flextable list: `tab_ft`, flextable object: `tab_fto`) to any of the placeholders on a slide:

```{r}
obnd = report_add_slide(obnd,
  template = "two_content_header_text",
  elements = list(
     title                 = list( content      = "Tables",
                                   type         = "text"),
     sub_title             = list( content      = "flextables can be created in two ways",
                                   type         = "text"),
     content_left_header   = list( content      = 'using "flextable"',
                                   type         = "text"),
     content_left          = list( content      = tab_ft,
                                   type         = "flextable"),
     content_right_header  = list( content      = 'using "flextable_objecct"',
                                   type         = "text"),
     content_right         = list( content      = tab_fto,
                                   type         = "text")))
```

### Saving presentations 

Once you are done adding content you can save the presentation to a file:

```{r}
save_report(obnd, tempfile(fileext = ".pptx"))
```

Which should look something like this:

```{r, echo=FALSE, fig.cap="Example PowerPoint output for workflow above.", out.width = '600px'}
knitr::include_graphics(system.file(package="onbrand", "graphics", "ppt_workflow_output.png"))
```


## Word

### Loading your Word template

The `read_template()` function is also used to create a new `onbrand` object for a Word report. This requires that you  supply the path to your Word template and the mapping file. This example points to files within the `onbrand` package:


```{r}
obnd = read_template(
  template = file.path(system.file(package="onbrand"), "templates", "report.docx"),
  mapping  = file.path(system.file(package="onbrand"), "templates", "report.yaml"))
```

### Adding content

Word report content is added using the ``report_add_doc_content()`` function. This expects the user to identify the ``type`` of content being supplied. At a high level the following types of content can be added:

- `"break"` - page break
- `"toc"` - table of contents
- `"ph"` - text content to substitute for placeholders in the document
placeholder content 
- `"text"` - a string of text (only possible when the type in the mapping file is text)
- `"imagefile"` - string containing the path to an image file 
- `"ggplot"` -  a ggplot object
- `"table"` - list containing table content and other options
- `"flextable"` - list containing flextable content and other options
- `"flextable_object"` - user-defined flextable object

Similar to adding PowerPoint content, you must also supply a list containing the content and information about the content. Examples of each of these will be provided in the sections below. However you should see the help for  ``report_add_doc_content()`` to get a detailed explanation of the format of ``content``.  

### Text

The content type ``"text"`` is the most straight forward way to add content to a Word document, and the ``content`` is a list that has three possible elements. The only one required is the ``text`` element. If you just want to add text in the default format (doc_def in the yaml mapping file), then this is all you need to do:

```{r}
obnd = report_add_doc_content(obnd,
  type     = "text",
  content  = list(text="Text with no style specified will use the doc_def text format."))
```

#### Styles

Alternatively you can specify any style defined in the `yaml` mapping file by adding a ``style`` element to the content list. This shows how to create multi level headers:

```{r}
obnd = report_add_doc_content(obnd,
  type     = "text",
  content  = list(text  ="First level header",
                  style = "Heading_1"))
obnd = report_add_doc_content(obnd,
  type     = "text",
  content  = list(text  ="Second level header",
                  style = "Heading_2"))
obnd = report_add_doc_content(obnd,
  type     = "text",
  content  = list(text  ="Third level header",
                  style = "Heading_3"))
```

#### Formats

The other element you may want to control is the format of the content. In the previous examples you just needed to provide character data, but there are three possible formats you can use:

- ``"text"`` - character string (previous examples)
- ``"fpar"`` - fpar object from ``officer``
- ``"md"`` - character string with markdown to be rendered (see the section on markdown below)

The following provide example ``"fpar"`` and ``"md"`` formats

```{r}
fpartext = fpar(
ftext("Formatted text can be created using the ", prop=NULL),
ftext("fpar ", prop=fp_text(color="green")),
ftext("command from the officer package.", prop=NULL))

obnd = report_add_doc_content(obnd,
  type     = "text",
  content  = list(text   = fpartext, 
                  format = "fpar",
                  style  = "Normal"))

mdtext = "Formatted text can be created using **<color:green>markdown</color>** formatting"
obnd = report_add_doc_content(obnd,
  type     = "text",
  content  = list(text   = mdtext,
                  format = "md",
                  style  = "Normal"))
```

### Figures

Similar to the PowerPoint example above we're going to create some figures. Both an image file (`imgfile`) and a ggplot object (`p`):
```{r}
p = ggplot() + annotate("text", x=0, y=0, label = "picture example")
imgfile = tempfile(pattern="image", fileext=".png")
ggsave(filename=imgfile, plot=p, height=5.15, width=9, units="in")
```

We can add these by specyfing the appropriate content type. The content list can contain different information. Typically you would either specify the image file or ggplot object as well as a caption:

```{r}
obnd = report_add_doc_content(obnd,
  type     = "imagefile",
  content  = list(image   = imgfile,
                  caption = "This is an example of an image from a file."))
```

```{r}
obnd = report_add_doc_content(obnd,
  type     = "ggplot",
  content  = list(image   = p,
                  caption = "This is an example of an image from a ggplot object."))
```

### Tables

Tables in Word are similar to the tables in PowerPoint. The table type can be either `table`, `flextable`, or `flextable_object`. Lets look this data frame to see how to use each of these:
```{r}
tdf =    data.frame(Parameters = c("Length", "Width", "Height"),
                    Values     = 1:3,
                    Units      = c("m", "m", "m") )
```

To insert a native Word table, you would use the `table` type and the content is just a list with an element named `table` that has the value of a dataframe. As with figures, the content list can have an optional caption as well. 

```{r}
tab_cont = list(table   = tdf,
                caption = "Word Table.")
obnd = report_add_doc_content(obnd,
  type     = "table",
  content  = tab_cont)
```

Flextables can be used with the `flextable` type and information like headers, header formatting, etc can be passed along. Onbrand will then construct the flextable for you. 

```{r}
tab_ft = list(table         = tdf,
              header_format = "md",
              header_top    = list(Parameters = "Name^2^",
                                   Values     = "*Value*",
                                   Units      = "**Units**"),
              cwidth        = 0.8,
              table_autofit = TRUE,
              caption       = "Flextable from onbrand abstraction",
              table_theme   = "theme_zebra")
obnd = report_add_doc_content(obnd,
  type     = "flextable",
  content  = tab_ft)   
```

Lastly, to have the most control over the table you can construct a flextable yourself and pass that along in the content.

```{r}
tab_fto = flextable(tdf)                      
obnd = report_add_doc_content(obnd,
  type     = "flextable_object",
  content  = list(ft=tab_fto,
                  caption  = "Flextable object created by the user."))
```

### Formatting sections

Section formatting, chaging the page orientation and/or the number of columns, is controlled using the ``"section"`` content type. It may seem a bit counter intuitive but sections apply to the content added **since the last** section type specification. So now lets try the following:

- Add a landscape figure
- Add two column text   
- Add more content in portrait 

To change formatting we need to close out the current section by inserting a portrait section type: 

```{r}
obnd = report_add_doc_content(obnd,
     type     = "section",
     content  = list(section_type  ="portrait"))
```

Then we add the content we want in landscape mode:

```{r}
obnd = report_add_doc_content(obnd,
  type     = "ggplot",
  content  = list(image   = p,
                  height  = 2.5,
                  width   = 9,
                  caption = "This is a landscape figure."))
```

Now we tell the underlying report to apply landscape formatting to everything that has been added since the portrait section type:

```{r}

obnd = report_add_doc_content(obnd,
  type     = "section",
  content  = list(section_type  ="landscape",
                  height        = 8,
                  width         = 10))
 
```

Now we want to add the text for the two column format:

```{r}
obnd = report_add_doc_content(obnd,
  type     = "text",
  content  = list(text    = paste(rep("Some two column text. ", 200), collapse=" ")))

```

Now we insert a section indicating that we want to change the section to multiple columns. The number of columns is inferred from the number of elements in the `widths` argument:

```{r}
obnd = report_add_doc_content(obnd,
  type     = "section",
  content  = list(section_type  ="columns",
                  widths        = c(3,3)))

```

We can now add content but don't forget to set the insert a portrait section at the end just before you save the document.

```{r}
obnd = report_add_doc_content(obnd,
  type          = "text",
  content       = list(text    = "Back to regular portrait"))
```

### Placeholder text

When generating reporting workflows it can be helpful to have placeholder text in the report that is populated based on the specifics of that report. To add placeholders you can use the `"ph"` content type. A placeholder is a unique string of text surrounded by === and ===. If the placeholder is in your template document, it may not work correctly if you type the text into Word. This is because while a string may appear to be a contiguous in Word, it may not be so in the underlying XML code. To ensure the string is contiguous you should type the placeholder text into a text editor, copy and paste it into template word. 

The placeholder can be in the document template itself or in the text you've added. In this example the text `===BODYPHEXAMPLE===` was in the content added above. That will be replaced with the text ``placeholder text in the body``. 


```{r}
obnd = report_add_doc_content(obnd,
  type     = "ph",
  content  = list(name     = "BODYPHEXAMPLE",
                  value    = "placeholder text in the body",
                  location = "body"))
```

You can have the placeholders in the body as in the previous example and also in the headers and footers of the document. In these examples the `===FOOTERLEFT===` and `===HEADERLEFT===` placeholders are found in the template itself. 

```{r}
obnd = report_add_doc_content(obnd,
  type     = "ph",
  content  = list(name     = "FOOTERLEFT",
                  value    = "Footer Placeholder",
                  location = "footer"))
obnd = report_add_doc_content(obnd,
  type     = "ph",
  content  = list(name     = "HEADERLEFT",
                  value    = "Header Placeholder",
                  location = "header"))
```

Headers are applied when the doucment is saved and can be added at any time to the onbrand report object.

### Formatting sections (again)

Recall up above that we were in a multi-column page format, but we wanted to return to the default portrait single column format. We added text but before we save the file we need to tell the document to apply the new section type:

```{r}
obnd = report_add_doc_content(obnd,
  type     = "section",
  content  = list(section_type  ="portrait"))
```

**Note that if you don't alter the page format/layout from the document default, then you do not need to add any section content.**

### Saving the Word report 

Once you are done adding content you can save the report to a file with the ``save_report()`` function as well:

```{r}
save_report(obnd, tempfile(fileext = ".docx"))
```

The output from the example above should look like this:

```{r, echo=FALSE, fig.cap="Example Word output for workflow above.", out.width = '600px'}
knitr::include_graphics(system.file(package="onbrand", "graphics", "doc_workflow_output.png"))
```
## Formatting with Markdown

In `officer` you can change formatting in text using `fpar` and `as_pargraph`. There are situations where this is less than ideal. For example if you want to take formatted user input from a Shiny app, it may not be practical to have them supply code this way. 

To make formatting a little easier, `onbrand` provides the ability to use markdown. This can be seen above in flextable objects for PowerPoint content and with text, captions in Word. For a list of allowed markdown formatting see the help for `md_to_officer()`. 

If you want to use the markdown functionality outside of `onbrand` you can use the two functions:

- `md_to_officer` - This function will take the markdown text and convert that into strings of text containing officer commands in `fpar` and `as_paragraph` commands. You simply need to use the `eval` command to execute them.
- `md_to_oo` - A function that wraps around `md_to_officer` and returns the `as_paragraph` result.

### Using ``md_to_oo`` to format 

First lets start with data. Here we have dimensional data listed as a mean and variance:

```{r}
data = data.frame(property = c("mean",   "variance"),
                  length     = c(200,      0.13),
                  width      = c(12,       0.05),
                  area       = c(240,      0.11),
                  volume     = c(1200,     0.32))

```

Now lets create a flextable object with a header that shows the property being reportged on one line and the units on the line below:

```{r}
header = list(property = c("",             ""),
              length   = c("Length",       "cm"),
              width    = c("Wdith",        "cm"),
              area     = c("Area",         "cm2"),
              volume   = c("Volume",       "cm3"))

ft = flextable::flextable(data)                     %>% 
     flextable::delete_part(part = "header")        %>%
     flextable::add_header(values =as.list(header)) %>%
     flextable::theme_zebra()
```

That flextable currently looks like this:

```{r echo=FALSE}
htmltools_value(ft)
```

Now we may want to customize some things. For example we may want to use exponents on the units and represent the mean and variance with $\mu$ and $\sigma^2$. First we need to create lists with the default value for the table labels (i.e. the header) and the table body. The markdown will create deviations from these defaults. You can look at the help for `md_to_oo` to get the appropriate list format. Here we're just pulling them out of the onbrand object using `fetch_md_def()`.

```{r}
dft      = fetch_md_def(obnd, style="Table_Labels")$md_def
dft_body = fetch_md_def(obnd, style="Table")$md_def
```

Now we can use the flextable `compose` function to walk through the table and overwrite the defaults that were set when the flextable was created:

```{r}
ft = ft %>%
  compose(j     = "area",
          part  = "header", 
          value = c(md_to_oo("Area", dft)$oo, md_to_oo("cm^2^", dft)$oo))   %>%
  compose(j     = "volume", 
          part  = "header",
          value = c(md_to_oo("Volume", dft)$oo, md_to_oo("cm^3^", dft)$oo)) %>%
  compose(j     = "property", 
          i     = match("mean", data$property),                        
          part  = "body",  
          value = c(md_to_oo("**<ff:symbol>m</ff>**", dft_body)$oo))    %>%
  compose(j     = "property",
          i     = match("variance", data$property), 
          part  = "body",                                                     
          value = c(md_to_oo("**<ff:symbol>s</ff>**^**2**^", dft_body)$oo))
```

Now the flextable object looks like this:

```{r echo=FALSE}
htmltools_value(ft)
```

**Note that the Greek symbols are not rendered correctly here but will be rendered correctly in Word.**

## Accessing the `officer` Object Directly

Sometimes you need more control over creating a report, and you may want to use the officer commands directly. To do this you can use the function `fetch_officer_object()`` to pull out the officer object from the onbrand object:

```{r echo=FALSE}
rpt = fetch_officer_object(obnd)$rpt
```

Now you can use any officer command you wish on the `rpt` object. And when you're done you can put the object back into the onbrand object using `set_officer_object()`:

```{r echo=FALSE}
obnd = set_officer_object(obnd, rpt)
```

## Maping File
```{r echo=FALSE, comment='', message=TRUE, eval=TRUE}
cat(readLines(file.path(system.file(package="onbrand"), "templates", "report.yaml")) , sep="\n")
```
